section .data
    msg db "Sum: ", 0       ; Сообщение перед суммой
    msg_len equ $ - msg      ; Длина сообщения

section .bss
    result resb 20          ; Резервируем место для строки с результатом

section .text
    global _start

_start:
    ; Инициализация
    mov rax, 0              ; Сумма
    mov rbx, 1              ; Начальное значение

    ; Цикл от 1 до 1000000000
.loop:
    add rax, rbx            ; Добавляем текущее значение к сумме
    inc rbx                 ; Увеличиваем текущее значение
    cmp rbx, 1000000000     ; Сравниваем с 1000000000
    jle .loop               ; Если меньше или равно, продолжаем цикл

    ; Преобразуем число в строку
    mov rdi, result         ; Адрес буфера для результата
    call int_to_str         ; Вызов функции преобразования

    ; Выводим сообщение
    mov rax, 1              ; Системный вызов write
    mov rdi, 1              ; Дескриптор файла stdout
    mov rsi, msg            ; Адрес сообщения
    mov rdx, msg_len        ; Длина сообщения
    syscall                 ; Выполнение системного вызова

    ; Выводим результат
    mov rax, 1              ; Системный вызов write
    mov rdi, 1              ; Дескриптор файла stdout
    mov rsi, result         ; Адрес строки с результатом
    mov rdx, 20             ; Длина строки с результатом (можно улучшить)
    syscall                 ; Выполнение системного вызова

    ; Завершение программы
    mov rax, 60             ; Системный вызов exit
    xor rdi, rdi            ; Код выхода 0
    syscall                 ; Выполнение системного вызова

; Функция для преобразования числа в строку
; Вход: rax - число
; Выход: rdi - адрес строки
int_to_str:
    mov rbx, 10             ; Основание системы счисления (10)
    mov rcx, rdi            ; Адрес буфера
    add rcx, 19             ; Переместить указатель в конец буфера
    mov byte [rcx], 0       ; Нулевой байт в конце строки
.reverse_loop:
    dec rcx                 ; Переместиться назад
    xor rdx, rdx            ; Обнулить rdx
    div rbx                 ; Разделить число на основание
    add dl, '0'             ; Преобразовать в ASCII
    mov [rcx], dl           ; Сохранить цифру в строке
    test rax, rax           ; Проверить, остались ли цифры
    jnz .reverse_loop       ; Если да, продолжить цикл
    ret
